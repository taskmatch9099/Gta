<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GTA-Style Sniper Duel (FPV/TPV)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0a0c10; color:#e8e8e8; font-family:Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    canvas { display:block; position:fixed; inset:0; width:100%; height:100%; }

    /* UI */
    #ui { position:fixed; inset:0; pointer-events:none; }
    #top { position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; gap:10px; }
    .team { display:flex; align-items:center; gap:10px; }
    .team .name { font-weight:700; letter-spacing:.5px; }
    .bars { display:flex; flex-direction:column; gap:6px; }
    .bar { width:240px; height:10px; background:rgba(255,255,255,.08); border-radius:6px; overflow:hidden; }
    .bar span { display:block; height:100%; width:100%; background:linear-gradient(90deg, #e74c3c, #c0392b); }
    .bar.armor span { background:linear-gradient(90deg, #3498db, #2980b9); }

    #bottom { position:absolute; bottom:10px; left:10px; right:10px; display:flex; justify-content:space-between; font-size:14px; opacity:.95; }
    #center-note { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; opacity:.8; }

    #crosshair { position:fixed; inset:0; pointer-events:none; }
    #crosshair .h, #crosshair .v { position:absolute; background:rgba(255,255,255,.85); }
    #crosshair .h { left:0; right:0; top:50%; height:1px; }
    #crosshair .v { top:0; bottom:0; left:50%; width:1px; }

    #scope { position:fixed; inset:0; display:none; pointer-events:none; }
    #scope.active { display:block; }
    #scope .mask { position:absolute; inset:0; background:rgba(0,0,0,.7); -webkit-mask:radial-gradient(circle at center, black 38vh, transparent 40vh); mask:radial-gradient(circle at center, black 38vh, transparent 40vh); }
    #scope .readout { position:absolute; bottom:28px; left:50%; transform:translateX(-50%); display:flex; gap:18px; font-size:13px; opacity:.85; }

    #notif { position:absolute; top:64px; right:10px; display:flex; flex-direction:column; gap:6px; font-size:14px; }
    .kf { opacity:.95; animation:slideIn .25s ease; }
    @keyframes slideIn { from { transform:translateX(20px); opacity:0; } to { transform:translateX(0); opacity:1; } }

    #menu { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(16,18,24,.9); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:20px 22px; pointer-events:auto; width:min(92vw,680px); }
    #menu h1 { margin:0 0 12px 0; }
    #menu .row { display:grid; grid-template-columns:140px 1fr; gap:12px; align-items:center; margin:8px 0; }
    #menu select, #menu button, #menu input[type="checkbox"] { background:rgba(255,255,255,.06); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:10px 12px; }
    #menu button { cursor:pointer; margin-top:10px; }
    #menu .row .inline { display:flex; align-items:center; gap:8px; }

    #scoreboard { position:fixed; inset:0; display:none; place-items:center; }
    #scoreboard.active { display:grid; }
    #scoreboard .panel { background:rgba(16,18,24,.92); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:22px 26px; }

    .camera-indicator { position:absolute; top:12px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.8; letter-spacing:.8px; background:rgba(255,255,255,.08); padding:4px 8px; border-radius:6px; }

    @media (max-width:720px){ .bar { width:180px; } }
  </style>
</head>
<body>
  <div id="ui">
    <div class="camera-indicator" id="camMode">FPV</div>
    <div id="top">
      <div class="team">
        <div class="name">Player 1</div>
        <div class="bars">
          <div class="bar"><span id="p1h"></span></div>
          <div class="bar armor"><span id="p1a"></span></div>
        </div>
      </div>
      <div class="team">
        <div class="name">Player 2</div>
        <div class="bars">
          <div class="bar"><span id="p2h"></span></div>
          <div class="bar armor"><span id="p2a"></span></div>
        </div>
      </div>
    </div>
    <div id="bottom">
      <div>Ammo: <span id="ammo">5</span>/<span id="mag">5</span></div>
      <div>Rounds: <span id="round">1</span>/<span id="roundMax">5</span> | Score <span id="scoreA">0</span>-<span id="scoreB">0</span></div>
    </div>
    <div id="center-note">LMB: Shoot | RMB: Aim/Scope | Shift: Run | C: Crouch | Z: Prone | F: Cover (near wall) | Q/E: Zoom (or Lean in cover) | V: Toggle FPV/TPV | R: Reload</div>

    <div id="crosshair"><div class="h"></div><div class="v"></div></div>

    <div id="scope">
      <div class="mask"></div>
      <div class="readout"><span id="zoomLbl">2.5x</span><span id="windLbl">Wind 0.0 m/s</span><span id="distLbl">Dist 0 m</span></div>
    </div>

    <div id="notif"></div>

    <div id="menu">
      <h1>Los Santos Sniper Duel</h1>
      <div class="row"><label>Mode</label><select id="mode"><option value="ai">AI Opponent</option><option value="local">Local PvP (Turn-based)</option></select></div>
      <div class="row"><label>Map</label><select id="map"><option value="city" selected>City Rooftops</option><option value="beach">Beach</option></select></div>
      <div class="row"><label>Rounds</label><select id="roundCount"><option>3</option><option selected>5</option><option>7</option></select></div>
      <div class="row"><label>Rifle</label><select id="rifle"><option value="heavy">Heavy Sniper</option><option value="marksman">Marksman</option><option value="scout">Scout</option></select></div>
      <div class="row"><label>Invert Look Y</label><div class="inline"><input type="checkbox" id="invertY"> <span style="opacity:.8;">Match real game look inversion</span></div></div>
      <div class="row"><label>Mouse Sensitivity</label><input type="range" id="sensitivity" min="0.2" max="2.0" value="1.0" step="0.05"></div>
      <button id="startBtn">Start</button>
      <div style="opacity:.75; font-size:12px; margin-top:10px;">Use your mouse to look around. Build incrementally and test frequently.</div>
    </div>

    <div id="scoreboard">
      <div class="panel">
        <h2 id="roundBanner">Round Over</h2>
        <div>Winner: <span id="roundWinner">Player 1</span></div>
        <div>Score: <span id="scoreText">1 - 0</span></div>
        <button id="nextRound">Next Round</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script>
    // --- Game State
    const Game = {
      mode: 'ai',
      rounds: 5,
      roundIdx: 1,
      score: [0,0],
      fpAmmo: 5,
      magSize: 5,
      isScoped: false,
      zoomLevels: [1.5, 2.5, 5],
      zoomIdx: 1,
      wind: new THREE.Vector3(1.5,0,0),
      camMode: 'FPV', // or 'TPV'
      canShoot: true,
      paused: true,
    };

    const Rifles = {
      heavy: { name:'Heavy Sniper', mag:5, dmgBody:60, dmgHead:200, muzzle:900, sway:0.35, recoil:0.004, reload:2.4 },
      marksman: { name:'Marksman', mag:8, dmgBody:45, dmgHead:140, muzzle:750, sway:0.28, recoil:0.003, reload:2.0 },
      scout: { name:'Scout', mag:10, dmgBody:38, dmgHead:120, muzzle:650, sway:0.22, recoil:0.0025, reload:1.8 },
    };

    const UI = {
      p1h: document.getElementById('p1h'), p2h: document.getElementById('p2h'), p1a: document.getElementById('p1a'), p2a: document.getElementById('p2a'),
      ammo: document.getElementById('ammo'), mag: document.getElementById('mag'),
      round: document.getElementById('round'), roundMax: document.getElementById('roundMax'),
      scoreA: document.getElementById('scoreA'), scoreB: document.getElementById('scoreB'),
      scope: document.getElementById('scope'), zoomLbl: document.getElementById('zoomLbl'), windLbl: document.getElementById('windLbl'), distLbl: document.getElementById('distLbl'),
      notif: document.getElementById('notif'),
      menu: document.getElementById('menu'), startBtn: document.getElementById('startBtn'),
      modeSel: document.getElementById('mode'), roundsSel: document.getElementById('roundCount'), rifleSel: document.getElementById('rifle'),
      invertY: document.getElementById('invertY'), sensitivity: document.getElementById('sensitivity'),
      scoreboard: document.getElementById('scoreboard'), roundWinner: document.getElementById('roundWinner'), scoreText: document.getElementById('scoreText'), nextRound: document.getElementById('nextRound'),
      camMode: document.getElementById('camMode'),
    };

    // --- Three.js Setup
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    document.body.appendChild(renderer.domElement);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);
    scene.fog = new THREE.FogExp2(0x0b0e12, 0.01);

    // Map state
    const MapState = { current:'city', objects:[] };
    function clearMap(){ MapState.objects.forEach(o=>scene.remove(o)); MapState.objects.length=0; coverObjects.length=0; }

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);

    const hemi = new THREE.HemisphereLight(0x7aa0ff, 0x1b1b1b, 0.9); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(120, 240, 100); sun.castShadow = true; scene.add(sun);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200), new THREE.MeshStandardMaterial({ color:0x1a1f26 }));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    // Collidable/cover-capable geometry registry
    const coverObjects = [];

    // Map builders
    function buildCity(){
      scene.background = new THREE.Color(0x0d1117);
      scene.fog = new THREE.FogExp2(0x0b0e12, 0.01);
      // city terrain already has big plane as ground
      MapState.objects.push(ground);
    }
    function buildBeach(){
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = null;
      // sand
      const sand = new THREE.Mesh(new THREE.PlaneGeometry(200,200,32,32), new THREE.MeshStandardMaterial({ color:0xf4e2b3 }));
      sand.rotation.x = -Math.PI/2; sand.receiveShadow=true; scene.add(sand); MapState.objects.push(sand);
      // water
      const water = new THREE.Mesh(new THREE.PlaneGeometry(220,220), new THREE.MeshStandardMaterial({ color:0x1ca3ec, transparent:true, opacity:0.7 }));
      water.position.z = -50; water.rotation.x = -Math.PI/2; water.receiveShadow=false; scene.add(water); MapState.objects.push(water);
      // simple palms
      function addPalm(x,z){
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,1,10), new THREE.MeshStandardMaterial({ color:0x8b5a2b })); trunk.position.set(x,5,z);
        const leaves = new THREE.Mesh(new THREE.ConeGeometry(4,8,8), new THREE.MeshStandardMaterial({ color:0x228B22 })); leaves.position.set(x,12,z);
        [trunk, leaves].forEach(m=>{ m.castShadow=true; scene.add(m); MapState.objects.push(m); });
      }
      addPalm(10,10); addPalm(-15,5); addPalm(20,-10);
      // cover on beach: crates/rocks lines
      for(let i=0;i<6;i++){
        const box = new THREE.Mesh(new THREE.BoxGeometry(6,2,2), new THREE.MeshStandardMaterial({ color:0x6b6b6b }));
        box.position.set(-40 + i*16, 1, -20 + (Math.random()*20-10));
        box.castShadow=box.receiveShadow=true; scene.add(box); MapState.objects.push(box); coverObjects.push(box);
      }
    }

    // Elevated platforms (rooftops)
    function createRooftop(x,z,h,color) {
      const g = new THREE.Group();
      const base = new THREE.Mesh(new THREE.BoxGeometry(30,h,30), new THREE.MeshStandardMaterial({ color }));
      base.position.set(x,h/2,z); base.castShadow=true; base.receiveShadow=true; g.add(base);
      const top = new THREE.Mesh(new THREE.PlaneGeometry(30,30), new THREE.MeshStandardMaterial({ color:0x2a2f36 }));
      top.rotation.x=-Math.PI/2; top.position.set(x,h+0.01,z); top.receiveShadow=true; g.add(top);

      // Parapet walls for cover
      const wallH = 1.2, thick = 0.3, size = 30;
      const wallMat = new THREE.MeshStandardMaterial({ color:0x3a404a, roughness:.9, metalness:.1 });
      const wN = new THREE.Mesh(new THREE.BoxGeometry(size, wallH, thick), wallMat); wN.position.set(x, h + wallH/2, z - size/2 + thick/2);
      const wS = new THREE.Mesh(new THREE.BoxGeometry(size, wallH, thick), wallMat); wS.position.set(x, h + wallH/2, z + size/2 - thick/2);
      const wW = new THREE.Mesh(new THREE.BoxGeometry(thick, wallH, size), wallMat); wW.position.set(x - size/2 + thick/2, h + wallH/2, z);
      const wE = new THREE.Mesh(new THREE.BoxGeometry(thick, wallH, size), wallMat); wE.position.set(x + size/2 - thick/2, h + wallH/2, z);
      [wN,wS,wW,wE].forEach(w => { w.castShadow=true; w.receiveShadow=true; g.add(w); coverObjects.push(w); });

      scene.add(g); return { group:g, roofY:h+1.6 };
    }
    let roofA, roofB;
    function buildCityGeometry(){
      roofA = createRooftop(-80, 0, 24, 0x3b4a5a);
      roofB = createRooftop( 80, 0, 28, 0x2f3c49);
      // Decorative buildings
      (function city(){
        const mat = new THREE.MeshStandardMaterial({ color:0x232a33, metalness:.2, roughness:.9 });
        for(let i=0;i<60;i++){
          const w=12+Math.random()*30,d=12+Math.random()*30,h=10+Math.random()*120;
          const m=mat.clone(); m.color.offsetHSL((Math.random()-.5)*.05,0,(Math.random()-.5)*.05);
          const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), m);
          b.position.set((Math.random()-.5)*900, h/2, (Math.random()-.5)*900);
          b.castShadow=true; b.receiveShadow=true; scene.add(b); coverObjects.push(b); MapState.objects.push(b);
        }
      })();
      MapState.objects.push(roofA.group, roofB.group);
    }
      const mat = new THREE.MeshStandardMaterial({ color:0x232a33, metalness:.2, roughness:.9 });
      for(let i=0;i<60;i++){
        const w=12+Math.random()*30,d=12+Math.random()*30,h=10+Math.random()*120;
        const m=mat.clone(); m.color.offsetHSL((Math.random()-.5)*.05,0,(Math.random()-.5)*.05);
        const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), m);
        b.position.set((Math.random()-.5)*900, h/2, (Math.random()-.5)*900);
        b.castShadow=true; b.receiveShadow=true; scene.add(b); coverObjects.push(b);
      }
    })();

    // Operators with basic tactical gear proxies
    function createOperator(theme){
      const palette = theme==='urban' ? {
        suit:0x111111, vest:0x1a1a1a, helmet:0x141414, trim:0x222222, skin:0xc8b39a, glove:0x2a2a2a, boot:0x1a1a1a
      } : {
        suit:0xc2ab7f, vest:0x8d7b5a, helmet:0xa7946b, trim:0x6e5f44, skin:0xe1d0b5, glove:0x6b5b3f, boot:0x4f4634
      };
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(.5,1.2,6,12), new THREE.MeshStandardMaterial({ color:palette.suit, roughness:.9 }));
      const head = new THREE.Mesh(new THREE.SphereGeometry(.35,16,16), new THREE.MeshStandardMaterial({ color:palette.skin })); head.position.y=1.3;
      // Vest / plate carrier
      const vest = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.9,0.45), new THREE.MeshStandardMaterial({ color:palette.vest })); vest.position.set(0,0.6,0);
      // Pouches
      for(let i=-1;i<=1;i++){
        const p = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.28,0.12), new THREE.MeshStandardMaterial({ color:palette.trim }));
        p.position.set(i*0.28,0.32,0.28); g.add(p);
      }
      // Helmet + goggles band
      const helmet = new THREE.Mesh(new THREE.SphereGeometry(.38,16,16,0,Math.PI*2,0,Math.PI/1.6), new THREE.MeshStandardMaterial({ color:palette.helmet })); helmet.position.y=1.62;
      const goggles = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.12,0.05), new THREE.MeshStandardMaterial({ color:0x222222 })); goggles.position.set(0,1.45,0.32);
      // Boots
      const bootL = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.18,0.32), new THREE.MeshStandardMaterial({ color:palette.boot })); bootL.position.set(-0.18,0.02,0.02);
      const bootR = bootL.clone(); bootR.position.x = 0.18;

      [body,head,vest,helmet,goggles,bootL,bootR].forEach(m=>{ m.castShadow=m.receiveShadow=true; g.add(m); });
      return { group:g, head, body };
    }

    const P1 = { health:100, armor:50, obj:null, head:null, body:null, ammo:5, reloading:false };
    const P2 = { health:100, armor:50, obj:null, head:null, body:null, ammo:5, reloading:false };

    // Stances and locomotion state
    const Stance = { STAND:'stand', CROUCH:'crouch', PRONE:'prone', COVER:'cover' };
    const stanceHeights = { stand:1.6, crouch:1.0, prone:0.4, cover:1.1 };
    const speeds = { walk:1.5, run:4.0, crouch:0.8, prone:0.3 };
    const ctrl = { stance:Stance.STAND, running:false, cover:false, coverNormal:new THREE.Vector3(), coverPoint:new THREE.Vector3(), lean:0, leanTarget:0, eyeCurrent:stanceHeights.stand, aimLerp:0 };

    function placePlayersOnCity(){
      const a = createOperator('desert'); a.group.position.set(roofA.group.position.x, roofA.roofY, roofA.group.position.z); scene.add(a.group); MapState.objects.push(a.group); P1.obj=a.group; P1.head=a.head; P1.body=a.body;
      const b = createOperator('urban');  b.group.position.set(roofB.group.position.x, roofB.roofY, roofB.group.position.z); scene.add(b.group); MapState.objects.push(b.group); P2.obj=b.group; P2.head=b.head; P2.body=b.body;
    }
    function placePlayersOnBeach(){
      const a = createOperator('desert'); a.group.position.set(-40, 1.6, 10); scene.add(a.group); MapState.objects.push(a.group); P1.obj=a.group; P1.head=a.head; P1.body=a.body;
      const b = createOperator('urban');  b.group.position.set( 40, 1.6,-10); scene.add(b.group); MapState.objects.push(b.group); P2.obj=b.group; P2.head=b.head; P2.body=b.body;
    }

    // FPV rifle model (simple box) attached to camera
    const fpvRifle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.6), new THREE.MeshStandardMaterial({ color:0x444, metalness:0.6, roughness:0.3 }));
    fpvRifle.position.set(0.35, -0.25, -0.6);
    camera.add(fpvRifle);

    // TPV rifle attached to player model
    const tpvRifle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.6), new THREE.MeshStandardMaterial({ color:0x666 }));
    tpvRifle.position.set(0.4, 0.8, -0.2);

    // Camera state and pointer lock
    const camState = { mode:'FPV', yaw:0, pitch:0, fovNormal:60, fovScoped:20, tpvDist:5, tpvHeight:2, invertY:false, sens:1.0, yawVel:0, pitchVel:0 };
    UI.camMode.textContent = camState.mode;

    function setBars(){ UI.p1h.style.width=P1.health+'%'; UI.p2h.style.width=P2.health+'%'; UI.p1a.style.width=P1.armor+'%'; UI.p2a.style.width=P2.armor+'%'; }
    function setAmmo(){ UI.ammo.textContent=P1.ammo; UI.mag.textContent=Game.magSize; }

    function equipRifle(key){
      const R = Rifles[key];
      Game.magSize = R.mag; P1.ammo = R.mag; P2.ammo = R.mag; setAmmo();
    }

    equipRifle('heavy');
    setBars();
    UI.roundMax.textContent = String(Game.rounds);

    // Resize
    function onResize(){
      const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize); onResize();

    // Pointer lock for mouse look
    let pointerLocked = false;
    function lockPointer(){ renderer.domElement.requestPointerLock?.(); }
    document.addEventListener('pointerlockchange', ()=>{ pointerLocked = document.pointerLockElement===renderer.domElement; });

    // Mouse look
    function onMouseMove(e){
      if(!pointerLocked) return;
      const base = 0.0022 * camState.sens;
      // Smooth mouse look: apply velocity then damp
      camState.yawVel += (-e.movementX) * base;
      const signY = camState.invertY ? 1 : -1;
      camState.pitchVel += (e.movementY * signY) * base;
    }
    window.addEventListener('mousemove', onMouseMove);

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      keys.add(e.code);
      switch(e.code){
        case 'KeyV': toggleCamera(); break;
        case 'KeyQ': if (ctrl.cover) { ctrl.leanTarget = -1; } else { setZoom(-1); } break;
        case 'KeyE': if (ctrl.cover) { ctrl.leanTarget =  1; } else { setZoom(1); } break;
        case 'KeyR': reload(); break;
        case 'KeyI': camState.invertY = !camState.invertY; UI.invertY && (UI.invertY.checked = camState.invertY); notify('Invert Y: ' + (camState.invertY?'ON':'OFF')); break;
        case 'ShiftLeft': case 'ShiftRight': ctrl.running = true; break;
        case 'KeyC': toggleCrouch(); break;
        case 'KeyZ': case 'KeyX': toggleProne(); break;
        case 'KeyF': if (ctrl.cover) exitCover(); else tryEnterCover(); break;
      }
    });
    window.addEventListener('keyup', (e)=>{ 
      keys.delete(e.code);
      if (e.code==='ShiftLeft' || e.code==='ShiftRight') ctrl.running = false;
      if ((e.code==='KeyQ' || e.code==='KeyE') && ctrl.cover) ctrl.leanTarget = 0;
    });

    // Context menu off for right-click scope
    window.addEventListener('contextmenu', (e)=> e.preventDefault());
    window.addEventListener('mousedown', (e)=>{
      if (Game.paused) return;
      if (e.button===0) shoot();
      if (e.button===2) toggleScope(true);
    });
    window.addEventListener('mouseup', (e)=>{ if(e.button===2) toggleScope(false); });

    function toggleScope(on){
      Game.isScoped = on; UI.scope.classList.toggle('active', on);
      camera.fov = on ? camState.fovScoped : camState.fovNormal; camera.updateProjectionMatrix();
    }
    function setZoom(dir){ Game.zoomIdx = Math.max(0, Math.min(Game.zoomLevels.length-1, Game.zoomIdx + dir)); UI.zoomLbl.textContent = Game.zoomLevels[Game.zoomIdx].toFixed(1) + 'x'; camera.fov = camState.fovNormal / (Game.zoomLevels[Game.zoomIdx] / Game.zoomLevels[1]); camera.updateProjectionMatrix(); }

    function toggleCamera(){
      camState.mode = camState.mode==='FPV' ? 'TPV' : 'FPV';
      UI.camMode.textContent = camState.mode;
      // model visibility
      const fpv = camState.mode==='FPV';
      if (!P1.obj) return;
      P1.obj.visible = true; // keep P1 visible for TPV; in FPV hide model near camera to avoid clipping
      // simple approach: move camera inside head for FPV, place tpv rifle on P1 in TPV
      if (fpv) { P1.obj.remove(tpvRifle); camera.add(fpvRifle); fpvRifle.visible = true; }
      else { camera.remove(fpvRifle); fpvRifle.visible = false; P1.obj.add(tpvRifle); }
    }

    function reload(){ if(P1.reloading) return; const R=Rifles[UI.rifleSel?.value||'heavy']; if(P1.ammo===R.mag) return; P1.reloading=true; setTimeout(()=>{ P1.ammo=R.mag; P1.reloading=false; setAmmo(); }, (R.reload||2)*1000); }

    function setStance(s){
      if (s===Stance.COVER){ ctrl.cover = true; ctrl.stance = Stance.COVER; return; }
      ctrl.cover = false; ctrl.stance = s; if (s!==Stance.COVER) ctrl.leanTarget = 0;
    }
    function toggleCrouch(){
      if (ctrl.stance===Stance.PRONE){ setStance(Stance.CROUCH); return; }
      setStance(ctrl.stance===Stance.CROUCH ? Stance.STAND : Stance.CROUCH);
    }
    function toggleProne(){
      setStance(ctrl.stance===Stance.PRONE ? Stance.STAND : Stance.PRONE);
    }

    function tryEnterCover(){
      const eye = P1.obj.position.clone(); eye.y += ctrl.eyeCurrent*0.8;
      const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y = 0; if (fwd.lengthSq()<1e-4) return; fwd.normalize();
      raycaster.set(eye, fwd);
      const hits = raycaster.intersectObjects(coverObjects, true);
      if (hits.length && hits[0].distance < 1.2){
        const h = hits[0];
        const n = h.face?.normal ? h.face.normal.clone().transformDirection(h.object.matrixWorld).normalize() : new THREE.Vector3().subVectors(eye, h.point).setY(0).normalize();
        ctrl.coverNormal.copy(n);
        ctrl.coverPoint.copy(h.point);
        setStance(Stance.COVER);
        notify('Cover');
      } else {
        notify('No cover nearby');
      }
    }
    function exitCover(){ ctrl.cover=false; if (ctrl.stance===Stance.COVER) ctrl.stance = Stance.CROUCH; ctrl.leanTarget = 0; notify('Exit cover'); }

    // Camera update
    const camPivot = new THREE.Object3D(); scene.add(camPivot); camPivot.add(camera);
    function updateCamera(dt){
      // integrate mouse look velocities with damping for smoothness
      const damping = 0.85;
      camState.yaw += camState.yawVel; camState.pitch += camState.pitchVel;
      camState.yawVel *= damping; camState.pitchVel *= damping;
      camState.pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, camState.pitch));

      const target = new THREE.Quaternion().setFromEuler(new THREE.Euler(camState.pitch, camState.yaw, 0, 'YXZ'));
      camera.quaternion.slerp(target, 0.18);

      // stance height interpolation (0.5s crouch, 1s prone approx)
      const tgtH = stanceHeights[ctrl.cover? 'cover' : ctrl.stance];
      const k = (ctrl.stance===Stance.PRONE) ? 2.0 : 4.0; // higher k -> faster
      ctrl.eyeCurrent += (tgtH - ctrl.eyeCurrent) * Math.min(1, dt * k);

      const eye = P1.obj.position.clone(); eye.y += ctrl.eyeCurrent;

      // update lean
      ctrl.lean += (ctrl.leanTarget - ctrl.lean) * Math.min(1, dt * 6);

      // head-bob and breathing
      const moving = (keys.has('KeyA')||keys.has('KeyD')||keys.has('KeyW')||keys.has('KeyS'));
      const t = performance.now()/1000; const bobAmp = moving ? 0.02 : 0.0; const breath = (!moving? 0.01 : 0.004);
      const bobX = Math.sin(t*10) * bobAmp; const bobY = Math.abs(Math.cos(t*20)) * bobAmp * 0.6 + Math.sin(t*2.2)*breath;

      // sway scaled down when scoped
      const swayBase = (Game.isScoped?0.25:1.0); const sway = Rifles[UI.rifleSel.value||'heavy'].sway * 0.08 * swayBase;
      const sx = Math.sin(t*1.2)*sway + bobX; const sy = Math.cos(t*1.4)*sway*0.6 + bobY;

      // cover lean lateral offset
      const right = new THREE.Vector3(1,0,0).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, camState.yaw, 0)));
      const leanOffset = ctrl.cover ? right.clone().multiplyScalar(ctrl.lean * 0.45) : new THREE.Vector3();

      // FPV rifle aim offset
      const aimTgt = Game.isScoped ? 1 : 0; ctrl.aimLerp += (aimTgt - ctrl.aimLerp) * Math.min(1, dt*8);
      const rifleBase = new THREE.Vector3(0.35, -0.25, -0.6);
      const rifleAim  = new THREE.Vector3(-0.02, -0.08, -0.45);
      const riflePos = rifleBase.clone().lerp(rifleAim, ctrl.aimLerp);
      fpvRifle.position.copy(riflePos);

      if (camState.mode==='FPV') {
        camera.position.lerp(new THREE.Vector3(eye.x+sx, eye.y+sy, eye.z).add(leanOffset), 0.25);
      } else {
        // third-person behind player
        const back = new THREE.Vector3(0, camState.tpvHeight, camState.tpvDist);
        back.applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(camState.pitch, camState.yaw, 0, 'YXZ')));
        const desired = eye.clone().add(new THREE.Vector3(sx, sy, 0)).add(leanOffset).sub(back);
        camera.position.lerp(desired, 0.1);
        camera.lookAt(eye.clone().add(leanOffset));
      }

      UI.zoomLbl.textContent = Game.zoomLevels[Game.zoomIdx].toFixed(1)+'x';
      const dist = camera.position.distanceTo(P2.obj.position); UI.distLbl.textContent = 'Dist ' + dist.toFixed(0) + ' m'; UI.windLbl.textContent = 'Wind ' + Game.wind.length().toFixed(1) + ' m/s';
    }

    // Shooting via raycaster (simple MVP)
    const raycaster = new THREE.Raycaster();
    function shoot(){
      if (!Game.canShoot) return;
      if (P1.reloading) return;
      if (P1.ammo<=0) { reload(); return; }

      // Muzzle flash
      const flash = new THREE.PointLight(0xffe08a, 2, 6); flash.position.copy(camera.position); scene.add(flash); setTimeout(()=>scene.remove(flash), 120);

      // Recoil based on stance
      const R = Rifles[UI.rifleSel.value||'heavy'];
      let recoilMul = 1.0;
      if (ctrl.stance===Stance.CROUCH || ctrl.stance===Stance.COVER) recoilMul = 0.8;
      if (ctrl.stance===Stance.PRONE) recoilMul = 0.6;
      if (ctrl.running) recoilMul *= 1.6;
      camera.rotation.x -= (R.recoil || 0.003) * recoilMul;

      // Ray from camera with dispersion based on motion/stance
      let dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      let spread = 0.002 + moveState.vel.length()*0.0015;
      if (ctrl.stance===Stance.CROUCH || ctrl.stance===Stance.COVER) spread *= 0.6;
      if (ctrl.stance===Stance.PRONE) spread *= 0.35;
      if (Game.isScoped) spread *= 0.4;
      if (ctrl.running) spread *= 1.8;

      // blind fire from cover: high inaccuracy
      if (ctrl.cover && Math.abs(ctrl.lean) < 0.1) spread *= 4.0;

      dir.x += (Math.random()-.5)*spread; dir.y += (Math.random()-.5)*spread*0.8; dir.z += (Math.random()-.5)*spread; dir.normalize();

      const origin = camera.position.clone().add(ctrl.cover && Math.abs(ctrl.lean)<0.1 ? new THREE.Vector3(0,0.25,0) : new THREE.Vector3());
      raycaster.set(origin, dir);

      // Build hit list with opponent head/body
      const candidates = [P2.head, P2.body];
      const intersects = raycaster.intersectObjects(candidates, false);

      // Tracer line
      const tracerLen = 2000; const tracerEnd = origin.clone().add(dir.clone().multiplyScalar(tracerLen));
      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, tracerEnd]), new THREE.LineBasicMaterial({ color:0xffe08a }));
      scene.add(line); setTimeout(()=>scene.remove(line), 80);

      P1.ammo--; setAmmo();

      if (intersects.length>0) {
        const hit = intersects[0];
        const bone = (hit.object===P2.head)?'head':'body';
        const dmg = (bone==='head')?R.dmgHead:R.dmgBody;
        applyDamage(P2, dmg);
        spawnImpact(hit.point, 0xffdd99);
        notify(ctrl.cover && Math.abs(ctrl.lean)<0.1 ? `Blind fire hit ${bone}!` : `Hit ${bone}!`);
        if (P2.health<=0) endRound(1);
      } else {
        notify(ctrl.cover && Math.abs(ctrl.lean)<0.1 ? 'Blind fire miss' : 'Miss');
      }

      Game.canShoot = false; setTimeout(()=>Game.canShoot=true, 300);

      // AI response if in AI mode
      if (Game.mode==='ai' && P2.health>0) setTimeout(aiShoot, 600 + Math.random()*700);
    }

    function spawnImpact(point, color){
      const p = new THREE.Points(new THREE.BufferGeometry().setFromPoints([point]), new THREE.PointsMaterial({ color:color||0xffffff, size:0.4 })); scene.add(p); setTimeout(()=>scene.remove(p), 350);
    }

    function notify(text){ const d=document.createElement('div'); d.className='kf'; d.textContent=text; UI.notif.prepend(d); setTimeout(()=>d.remove(), 3000); }

    function applyDamage(target, amount){
      let remain = amount;
      if (target.armor>0){ const ar = Math.min(target.armor, remain*0.7); target.armor -= ar; remain -= ar*0.6; }
      target.health = Math.max(0, target.health - remain);
      setBars();
    }

    // Round flow
    function endRound(winner){
      Game.score[winner-1]++;
      UI.roundWinner.textContent = 'Player ' + winner;
      UI.scoreText.textContent = Game.score[0] + ' - ' + Game.score[1];
      UI.scoreA.textContent = Game.score[0]; UI.scoreB.textContent = Game.score[1];
      UI.scoreboard.classList.add('active');
      Game.paused = true;
    }

    UI.nextRound.addEventListener('click', ()=>{
      UI.scoreboard.classList.remove('active');
      Game.roundIdx++;
      if (Game.roundIdx>Game.rounds) { Game.roundIdx=1; Game.score=[0,0]; }
      UI.round.textContent = Game.roundIdx;
      resetRound();
      Game.paused=false;
    });

    function resetRound(){
      P1.health=100; P1.armor=50; P2.health=100; P2.armor=50; setBars();
      if (MapState.current==='city'){
        P1.obj.position.x = roofA.group.position.x + (Math.random()-.5)*6; P1.obj.position.z = roofA.group.position.z + (Math.random()-.5)*6;
        P2.obj.position.x = roofB.group.position.x + (Math.random()-.5)*6; P2.obj.position.z = roofB.group.position.z + (Math.random()-.5)*6;
      } else {
        P1.obj.position.set(-40 + (Math.random()-.5)*6, 1.6, 10 + (Math.random()-.5)*6);
        P2.obj.position.set( 40 + (Math.random()-.5)*6, 1.6,-10 + (Math.random()-.5)*6);
      }
      camState.yaw = 0; camState.pitch = 0; camera.fov = camState.fovNormal; camera.updateProjectionMatrix();
      toggleScope(false);
    }

    // AI opponent
    function aiShoot(){
      if (Game.paused || Game.mode!=='ai' || P2.health<=0) return;
      if (P2.ammo<=0) P2.ammo = Game.magSize;
      const dir = P1.obj.position.clone().add(new THREE.Vector3(0,1.5,0)).sub(P2.obj.position.clone().add(new THREE.Vector3(0,1.3,0))).normalize();
      // accuracy
      dir.x += (Math.random()-.5)*0.01; dir.y += (Math.random()-.5)*0.006; dir.z += (Math.random()-.5)*0.004; dir.normalize();
      // Ray from AI towards player
      raycaster.set(P2.obj.position.clone().add(new THREE.Vector3(0,1.3,0)), dir);
      const inter = raycaster.intersectObjects([P1.head, P1.body], false);
      const tracerEnd = P2.obj.position.clone().add(new THREE.Vector3(0,1.3,0)).add(dir.multiplyScalar(2000));
      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([P2.obj.position.clone().add(new THREE.Vector3(0,1.3,0)), tracerEnd]), new THREE.LineBasicMaterial({ color:0xff8080 })); scene.add(line); setTimeout(()=>scene.remove(line), 120);
      if (inter.length>0){ const bone=(inter[0].object===P1.head)?'head':'body'; const dmg=(bone==='head')?Rifles[UI.rifleSel.value||'heavy'].dmgHead:Rifles[UI.rifleSel.value||'heavy'].dmgBody; applyDamage(P1, dmg); spawnImpact(inter[0].point, 0xffaaaa); notify('AI hit your ' + bone + '!'); if (P1.health<=0) endRound(2); }
      else notify('AI missed');
    }

    // Movement (WASD) limited to rooftop with stances and cover
    const moveState = { vel:new THREE.Vector2(0,0), accel:22, decel:14, max:4.0 };
    function currentMaxSpeed(){
      let s = speeds.walk;
      if (ctrl.stance===Stance.CROUCH || ctrl.stance===Stance.COVER) s = speeds.crouch;
      else if (ctrl.stance===Stance.PRONE) s = speeds.prone;
      else if (ctrl.running) s = speeds.run; else s = speeds.walk;
      if (Game.isScoped) s *= 0.5;
      return s;
    }
    function stepMovement(dt){
      let x=0,z=0; if(keys.has('KeyA'))x-=1; if(keys.has('KeyD'))x+=1; if(keys.has('KeyW'))z-=1; if(keys.has('KeyS'))z+=1; let l=Math.hypot(x,z);
      if (ctrl.stance===Stance.PRONE) { x=0; l=Math.abs(z); } // crawl forward/back only
      if(l>0){ x/=l; z/=l; }
      moveState.max = currentMaxSpeed();

      // desired velocity in view space (strafe)
      const desired = new THREE.Vector2(x, z).multiplyScalar(moveState.max);
      const to = desired.clone().sub(moveState.vel);
      const accel = (l>0?moveState.accel:moveState.decel) * dt;
      const step = Math.min(to.length(), accel);
      if (to.length()>1e-4) moveState.vel.add(to.normalize().multiplyScalar(step)); else moveState.vel.set(0,0);

      const yaw = camState.yaw;
      let forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      let right = new THREE.Vector3(-forward.z, 0, forward.x);

      // If in cover, constrain movement along wall tangent
      if (ctrl.cover){
        const tangent = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), ctrl.coverNormal).normalize();
        // re-project forward/right to align with tangent
        right = tangent.clone();
        forward = new THREE.Vector3().crossVectors(right, new THREE.Vector3(0,1,0)).normalize();
        // snap player slightly against cover plane
        const desiredPos = ctrl.coverPoint.clone().add(ctrl.coverNormal.clone().multiplyScalar(-0.55));
        P1.obj.position.x = THREE.MathUtils.lerp(P1.obj.position.x, desiredPos.x, Math.min(1, dt*8));
        P1.obj.position.z = THREE.MathUtils.lerp(P1.obj.position.z, desiredPos.z, Math.min(1, dt*8));
      }

      const dir = new THREE.Vector3();
      dir.addScaledVector(right, moveState.vel.x * dt);
      dir.addScaledVector(forward, moveState.vel.y * dt);

      // bounds
      P1.obj.position.x = THREE.MathUtils.clamp(P1.obj.position.x + dir.x, roofA.group.position.x-12, roofA.group.position.x+12);
      P1.obj.position.z = THREE.MathUtils.clamp(P1.obj.position.z + dir.z, roofA.group.position.z-12, roofA.group.position.z+12);

      // leave cover if moving away from it
      if (ctrl.cover && Math.abs(moveState.vel.x)+Math.abs(moveState.vel.y) > 0.1){
        const away = new THREE.Vector3(P1.obj.position.x,0,P1.obj.position.z).sub(new THREE.Vector3(ctrl.coverPoint.x,0,ctrl.coverPoint.z)).dot(ctrl.coverNormal);
        if (away > 0.6) exitCover();
      }
    }

    // Animation loop
    let last = performance.now();
    function animate(now){
      const dt = Math.min(0.033, (now-last)/1000); last = now;
      if(!Game.paused){ stepMovement(dt); updateCamera(dt); }
      // simple water shimmer on beach
      if (MapState.current==='beach'){
        const w = MapState.objects.find(o=>o.geometry && o.geometry.parameters && o.geometry.parameters.height===220); // crude pick for water plane created above
        if (w) w.position.y = Math.sin(now*0.001)*0.2;
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Menu start
    UI.startBtn.addEventListener('click', ()=>{
      Game.mode = UI.modeSel.value; Game.rounds = parseInt(UI.roundsSel.value,10); Game.roundIdx=1; UI.roundMax.textContent=String(Game.rounds); UI.round.textContent=String(Game.roundIdx);
      equipRifle(UI.rifleSel.value);
      camState.invertY = !!UI.invertY.checked;
      camState.sens = parseFloat(UI.sensitivity.value||'1.0');

      // Build selected map
      clearMap();
      const mapSel = document.getElementById('map');
      MapState.current = (mapSel?.value||'city');
      // remove prior city-only geometry if any
      if (MapState.current==='city'){
        buildCity(); buildCityGeometry(); placePlayersOnCity();
      } else {
        buildBeach();
        placePlayersOnBeach();
      }

      UI.menu.style.display='none'; Game.paused=false; lockPointer();
    });
  </script>
</body>
</html>
